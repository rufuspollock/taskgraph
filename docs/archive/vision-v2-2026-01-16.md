# Vision v2 2026-01-16

https://chatgpt.com/share/696c47d8-c82c-800a-9e65-bcc1e028bb55 /  https://chatgpt.com/g/g-p-694b6cd932088191933dfce640b086ff/c/696b61a5-04b0-8321-933e-d54089b09426

> OK, so the next one. For me, the current aim, I've often started a backlog of tasks, also face some quick design. So what I want to create is I want somewhere where I generate formal work for our projects and a list of tasks somewhere just like that at a huge hopper of tasks for myself to work on. I'm not having to look for all the different projects and the issue tracker and all that stuff. Mostly I have this stuff, by the way, in Obsidian and the folders. I also want to do prioritization. Every so often I want to say, which project should I work on? But basically, given a given amount of time, like I might have 10 minutes or I might have an hour, I might be able to do deep work, which is like quick and easy. I want to have a task and not having to go and find it. Often what happens when I'm starting deep work on a day, I'll spend like half an hour digging through my backlog of projects and deciding which are important, then digging out what is the actual task. Maybe there isn't a clear next task to do. I have to work that out. Or I've got 10 minutes, so I've got five minutes or 10 minutes to try and find the task to do. And that's the thing that's pain too. So I want something that allows me to really do that task, just have that backlog of tasks and then I just pull things off the back of that backlog. So first of all, what we need to do is clarify what we need by my project desire. And then with maybe multiple choice questions, one at a time that I clarify. And then that will end up, we're going to create basically a brief before an AI agent to go implement this. So that's what we're doing now is clarifying the actual need.

## TaskGraph — tight implementation brief (v0)

### Objective

Produce a working command-line tool that, when run, prints a small set of plausible next tasks drawn from an Obsidian vault, grouped by coarse effort/context categories, with enough context to act immediately. Correctness, sophistication, and generality are explicitly secondary to usefulness.

---

## User-facing behaviour (hard requirements)

### Primary command

`task-hopper`

When executed, the command prints **a fixed-format shortlist of tasks**, for example:

* Short tasks (≈ ≤10 minutes)
* Medium tasks (≈ 20–40 minutes)
* Deep-work tasks (≈ ≥90 minutes)

Each category should contain **up to 3 tasks**.

No flags, no configuration, no interactive prompts in v0.

### Output format (minimum)

For each task:

* Task text
* Source file path
* Line number (or nearest equivalent)
* One-line context (nearest heading or inferred project)

Example (illustrative only):

```
SHORT (≤10 min)
- Fix typo in README
  projects/flowershow/notes.md:142
  Context: FlowerShow – Docs cleanup
```

The output should be readable in a terminal and copy-pastable.

---

## Task selection semantics

### What counts as a task

* Markdown task syntax (e.g. `- [ ] …`)
* Only unchecked / open tasks
* Ignore completed tasks

### What must be surfaced

* Only **leaf tasks** (i.e. tasks that do not obviously contain unchecked subtasks beneath them)
* Tasks may appear anywhere in the vault, but v0 may restrict scope (e.g. `/projects` directory)

### Context inference (best-effort)

* Prefer nearest enclosing heading
* Fall back to file name
* Fall back to directory name

Precision is not required; plausibility is sufficient.

---

## Effort classification (heuristic, v0)

Hard-code simple rules; do not expose configuration.

Acceptable heuristics include:

* Explicit time hints in task text (e.g. “5 min”, “quick”, “draft”, “plan”)
* Task length (character count)
* Presence of verbs like “plan”, “design”, “write” → deep
* File or folder name signals (e.g. “planning”, “admin”)

If classification is ambiguous, assign arbitrarily; this is acceptable in v0.

---

## Architecture (constrained but flexible)

### Commands

1. `index` (internal or explicit)

   * Scans a fixed Obsidian directory
   * Extracts tasks + shallow context
   * Writes a **derived, regenerable index** (any simple local format)

2. `suggest` (invoked by default)

   * Reads the index
   * Applies ranking + grouping heuristics
   * Prints the shortlist

It is acceptable for `task-hopper` to implicitly run both steps.

### State

* State is allowed but must be:

  * Derived entirely from Obsidian
  * Safe to delete at any time
* No write-back to Obsidian.

---

## Non-goals (explicit)

* No UI beyond stdout
* No MCP
* No GitHub integration
* No persistent task editing
* No attempt at full GTD semantics
* No guarantees of optimal prioritisation

---

## Success criteria (v0)

After daily use for ~1 week:

* The command replaces manual searching for “what to do next”.
* Output usually contains at least one task that feels immediately actionable.
* Running it feels cheaper than thinking about alternatives.

---

## Failure conditions (v0)

The implementation should be considered unsuccessful if:

* It regularly surfaces tasks that require hunting for context.
* It feels like “another list” rather than a decision aid.
* It requires manual upkeep to stay usable.

---

## Implementation freedom

The implementation agent may:

* Choose language, libraries, and storage freely.
* Start with a restricted directory or small vault.
* Iterate heuristics aggressively.

The only invariant is: **one command → a small, decisive set of next tasks**.

---

If you want, next we can:

* translate this directly into an agent prompt, or
* sketch the minimal data structures the agent is allowed to invent, or
* define a first-week evaluation checklist before coding starts.

---
---

## Appendix: Clarified Product Need: Central Task Hopper and Selector

### Core Problem

Excessive time and cognitive load are spent deciding *what to work on*, rather than doing the work. Tasks are fragmented across projects, tools, and repositories, making both deep work and short time windows inefficient.

### Primary Aim

Create a single, low-friction system that reliably surfaces the *right next task*—quickly—without manual triage or ongoing maintenance.

---

## Task Model

### Task Definition

* Only **explicit, actionable tasks** appear in the system.
* “Figure out the next task” is itself a valid task.
* Tasks may range from ~5 minutes to several hours (deep work).
* Rough time/effort estimates are desirable; inference is acceptable.

### Task–Project Relationship

* Tasks almost always belong to a project.
* Some standalone “inbox” tasks (e.g. personal admin) are allowed.
* Tasks are primary; projects act as filters and priority signals, not mandatory entry points.

### Task State

* Conceptually GTD-style (open / next / waiting / scheduled / done).
* MVP implementation: **open vs done**, plus a lightweight “next” marker.
* Must align cleanly with existing systems (e.g. GitHub open/closed).

---

## Prioritisation and Selection

### Priority Authority

* You set **project priorities periodically**.
* The system computes task ranking using signals such as:

  * Project priority
  * Time/effort fit
  * Context/energy constraints
* Final choice remains yours, but should be lightweight.

### Selection Criteria

* Supports time availability (e.g. 10 minutes vs 2 hours).
* Supports cognitive/energy mode and situational context.
* Goal is a **ranked shortlist**, not perfect optimisation.

---

## Interaction Model (MVP)

* Simplest possible interface:

  * A surfaced shortlist (e.g. quick tasks vs deep tasks).
  * You pick and work.
* No requirement to choose a project first.
* Advanced interaction (chat/voice/natural language) explicitly deferred.

---

## Sources of Tasks

### Ingestion

* Hybrid model:

  * Explicit tasks pulled from existing systems.
  * Future: system-suggested next actions.
* MVP focus:

  * **Obsidian-first** (vault scanning and normalisation).
  * GitHub issues later.
* System acts primarily as an **interface over existing stores**, not a new source of truth.

---

## Automation and Refresh

* Automatic refresh on a regular cadence (e.g. daily).
* Manual “recompute now” trigger available.
* No requirement for constant background syncing.

---

## Success Criteria (Ranked)

1. Steady progress on highest-priority projects.
2. Significantly less time deciding what to work on.
3. Better use of short, fragmented time windows.

---

## Failure Modes to Avoid

* Becoming “another place to check.”
* Requiring ongoing manual maintenance to stay useful.
* Fragmenting attention rather than collapsing it.

---

## Hard Constraints for v1

1. **Extremely low setup and maintenance cost** (primary).
2. **Obsidian-first integration** (secondary).
3. Correctness and sophistication are explicitly secondary to usefulness.
4. Mobile usability is desirable but not a blocker.

---

If you want, the next step can be:

* a concise *system architecture sketch* (Obsidian → normaliser → selector), or
* a comparison of *technical design options* (plugin, CLI, local agent, hosted service), or
* a draft *implementation brief for an AI agent*.


